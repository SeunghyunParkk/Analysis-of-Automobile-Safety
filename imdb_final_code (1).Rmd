---
title: "Midterm"
output: html_document
date: "2023-10-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set.seed(42) 
```


## R Markdown
```{r}
library(knitr)
library(stringr)
library(dplyr)

# %>% - we use this to store function output and pass it to 

imdb = read.csv("IMDB_data_Fall_2023.csv")
attach(imdb)

#Removing genres dummy as they are not covering all the genres
imdb = imdb[,-(27:39)]

# Step 1: Identify all unique genres
all_genres = imdb %>%
  pull(genres) %>%
  str_split("\\|") %>%
  unlist() %>%
  unique()

# Step 2: For each genre, create a new column
for (genre in all_genres) {
  column_name <- str_c("genre_", genre) %>% str_replace_all(" ", "_")  # Create a valid column name
  imdb <- imdb %>%
    mutate(!!column_name := as.integer(str_detect(genres, fixed(genre))))
}
```

#Ensuring variable name consistency
```{r}
imdb$genre_Sci_Fi=imdb$`genre_Sci-Fi`
imdb = imdb[,-c(39)]

#Removing original genres
imdb = imdb[,-(24)]
```



```{r}

library(ggplot2)
library(dplyr)

a = names(imdb)

color_palette <- c("#003f5c", "#58508d", "#bc5090", "#ff6361", "#ffa600")

for (i in 1:28) {
  if (is.character(imdb[[a[i]]])) {
    category_counts <- table(imdb[[a[i]]]) %>%
      as.data.frame() %>%
      arrange(desc(Freq)) %>%
      mutate(Category = factor(Var1, levels = Var1)) # Convert to factor to retain order in ggplot
    
    # If there are more than 20 categories, keep only the top 20
    if (nrow(category_counts) > 20) {
      category_counts <- head(category_counts, 20)
    }
    
    plot = ggplot(category_counts, aes(x = Category, y = Freq)) +
      geom_bar(stat = "identity", fill = color_palette[i %% length(color_palette) + 1]) +
      geom_text(aes(label = Freq), vjust = -0.5, size = 3) +
      labs(title = paste("Bar Plot for Top Categories in Column", a[i]), x = "Category", y = "Frequency") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
    print(plot)
  }
}

    
```


```{r}
a = names(imdb)

library(ggplot2)

color_palette <- c("#003f5c", "#58508d", "#bc5090", "#ff6361", "#ffa600")

for (i in 1:9) {
  if (is.numeric(imdb[[a[i]]])){
    plot = ggplot(imdb, aes_string(x = a[i])) +
      geom_histogram(aes(y = ..density..), bins = 20, fill = color_palette[i %% length(color_palette) + 1]) +
      stat_function(fun = dnorm, args = list(mean = mean(imdb[[a[i]]], na.rm = TRUE), 
                                             sd = sd(imdb[[a[i]]], na.rm = TRUE)), 
                    color = "black", size = 1) +
      labs(title = paste("Histogram with Normal Curve for", a[i]), x = a[i], y = "Density") +
      theme_minimal()
    print(plot)
  }
}
```


```{r}
library(ggplot2)

color_palette <- c("#003f5c", "#58508d", "#bc5090", "#ff6361", "#ffa600")

for (i in 1:9) {
  if (is.numeric(imdb[[a[i]]])){
    plot <- ggplot(imdb, aes(x = factor(1), y = .data[[a[i]]])) +
      geom_boxplot(fill = color_palette[i %% length(color_palette) + 1]) +
      labs(title = paste("Boxplot for", a[i]), y = a[i], x = "") +
      theme_minimal() +
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())
    print(plot)
  }
}

```


```{r}

library(ggplot2)

ggplot(imdb, aes(x = imdb_score)) +
  geom_histogram(binwidth = 0.5, fill = "#003f5c", color = "white") +
  labs(title = "Histogram of IMDb Scores", x = "IMDb Score", y = "Count") +
  theme_minimal() +
  theme(text = element_text(size = 16))  # Adjust the size as needed

```



Dummifying keywords based on top 20 keywords (with each dummy for one of the top 20 keyword
and rest belong to others)


```{r}
library(dplyr)
library(tidyr)

# 1. Extract Keywords
keywords <- imdb %>%
  select(plot_keywords) %>%
  mutate(plot_keywords = strsplit(as.character(plot_keywords), '\\|')) %>%
  unnest(plot_keywords) %>%
  mutate(plot_keywords = trimws(plot_keywords))

# 2. Count Keywords
keyword_counts <- keywords %>%
  group_by(plot_keywords) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# 3. Select Top Keywords
top_keywords <- head(keyword_counts, 20) %>% pull(plot_keywords)

# 4. Adjust the keywords, keeping only the top ones or marking as 'Other'
imdb <- imdb %>%
  mutate(
    adjusted_keywords = lapply(
      strsplit(as.character(plot_keywords), '\\|'),
      function(keyword_list) {
        adjusted_list <- sapply(keyword_list, function(keyword) {
          if (keyword %in% top_keywords) {
            return(keyword)
          } else {
            return('Other')
          }
        })
        # Deduplicate the list (remove repeating 'Other')
        return(unique(adjusted_list))
      }
    )
  ) %>%
  mutate(row_id = row_number())  # Add row identifier

# 5. Create Dummy Variables
imdb_dummies <- imdb %>%
  select(row_id, adjusted_keywords) %>%
  unnest(adjusted_keywords) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = row_id, names_from = adjusted_keywords, values_from = dummy, values_fill = list(dummy = 0), names_prefix = "keyword_")

# Join the dummy variables with the original data
imdb <- left_join(imdb, imdb_dummies, by = "row_id") %>%
  select(-row_id, -adjusted_keywords)  # Remove the row identifier and adjusted_keywords column


```


```{r}

imdb$keyword_high_school = imdb$`keyword_high school`
imdb$keyword_new_york_city = imdb$`keyword_new york city`
imdb$keyword_cult_film = imdb$`keyword_cult film`
imdb$keyword_serial_killer = imdb$`keyword_serial killer`
imdb = imdb[,-c(51,54,56,62)]
```


```{r}
# Function to categorize maturity ratings
categorize_maturity_rating <- function(rating) {
  if (rating %in% c('PG-13', 'PG', 'R')) {
    return(rating)
  } else {
    return('Others')
  }
}

# Apply the function to the 'maturity_rating' column
imdb$maturity_rating <- sapply(imdb$maturity_rating, categorize_maturity_rating)

# Dummify the 'maturity_rating' column
dummy_vars <- model.matrix(~ maturity_rating - 1, data = imdb) %>%
              as.data.frame()

# Keep only 'PG-13', 'PG', and 'R' columns, if they exist
dummy_vars <- dummy_vars[, colnames(dummy_vars) %in% c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')]

# If the columns don't exist in the dummy_vars (because they might not be present in the original data), 
# we need to create them and set them to zero.
necessary_columns <- c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')
for (col in necessary_columns) {
  if (!col %in% colnames(dummy_vars)) {
    dummy_vars[[col]] <- 0
  }
}

# Bind the dummy variables with the original dataframe
imdb <- cbind(imdb, dummy_vars)

# This will print the first few rows of your dataframe
head(imdb)
```


We also observed that the movie ID for The Rocket: The Legend of Rocket Richard and The Rocker is same, so we will modify the movieID of The Rocker so that movie ID can be used as an unique identifier for the dataframe

```{r}
library(dplyr)
imdb = mutate(imdb, movie_id = ifelse(movie_id == 2667 & movie_title == "The Rocker", 2668, movie_id))
```

Removing variables from the dataset which seem irrelevant

```{r}
imdb = imdb[,-c(1,2,3,6,8,17,19,21,23)]
```


```{r}

#Classified the production companies that produced more than 18 movies into famous category and the ones with lesser than 18 movies as non-famous. Created dummy with 1 = famous and 0 = non-famous

library(dplyr)

# Assuming your data is in a dataframe called 'imdb'

# Ensure that production_company is a character vector, not a factor
imdb$production_company <- as.character(imdb$production_company)

# Count occurrences of each production company
production_counts <- as.data.frame(table(imdb$production_company))

# Name the columns for clarity
names(production_counts) <- c("production_company", "count")

# Categorize as 'famous' or 'non-famous'
production_counts$production_by <- ifelse(production_counts$count >= 18, 'famous', 'non-famous')

# Merge this information back into the original dataframe
imdb <- merge(imdb, production_counts[, c("production_company", "production_by")], by = "production_company")

# Create a dummy variable for 'famous'
imdb$famous_production_company <- ifelse(imdb$production_by == 'famous', 1, 0)


```


```{r}
#Removing original production_company and plot_keywords column
imdb = imdb[,-c(1,17)]
```


```{r}

#We observed that there 1115 unique directors, with a large portion of directors directing 1 or 2 movies. Therefore, we decided to split the directors columns into 3 categories where extremely prolific is the director directing more than 2 movies. Very prolific is the director directing 2 movies and low prolific is the director director direction 1 or 0 movies.

library(dplyr)

# First, ensure that 'director' is a factor
imdb$director <- as.factor(imdb$director)

# Calculate the number of movies for each director
director_counts <- table(imdb$director)

# Function to categorize directors based on director counts
categorize_director <- function(director_name) {
  count <- director_counts[director_name]
  if (count > quantiles[2]) {
    return("Extremely Prolific")
  } else if (count > quantiles[1]) {
    return("Medium Prolific")
  } else {
    return("Less Prolific")
  }
}

# Calculate the quantiles based on the number of movies directed
quantiles <- quantile(director_counts, probs = c(0.3, 0.7))

# Categorize directors
imdb$director_category <- sapply(imdb$director, categorize_director)

# Create dummy variables
imdb <- imdb %>%
  mutate(
    director_extremely_prolific = ifelse(director_category == "Extremely Prolific", 1, 0),
    director_very_prolific = ifelse(director_category == "Medium Prolific", 1, 0)
  )

# View the first few rows of the modified dataframe
head(imdb)


```


```{r}
library(dplyr)

# Ensure that 'distributor' is a factor
imdb$distributor <- as.factor(imdb$distributor)

# Define the threshold
threshold <- 40

# Calculate the number of movies for each distributor
distributor_counts <- table(imdb$distributor)

# Function to categorize distributors
categorize_distributor <- function(distributor_name) {
  count <- distributor_counts[distributor_name]
  if (count > threshold) {
    return("Major Distributors")
  } else {
    return("Independent Distributors")
  }
}

# Categorize distributors
imdb$distributor_category <- sapply(imdb$distributor, categorize_distributor)

# Create a dummy variable for major distributors
imdb$major_distributor <- ifelse(imdb$distributor_category == "Major Distributors", 1, 0)

# View the first few rows of the modified dataframe
head(imdb)

```

```{r}
#Removing director category, production company and distribution company variables which contained the new custom categories we created. We have already created dummies using those custom categories.

imdb = imdb[,-c(63,65,68)]
```



```{r}
#Removing languages as it is an almost unary predictor

imdb = imdb[,-c(5)]

```


```{r}
# Transform the 'country' column
imdb <- imdb %>%
  mutate(country = ifelse(country == 'USA', 'USA', 'Non-USA'))

# Create a dummy variable
imdb$country_usa <- ifelse(imdb$country == 'USA', 1, 0)

# View the first few rows of the modified dataframe
head(imdb[, c("country", "country_usa")])
```

```{r}
#Removing original country variable
imdb = imdb[,-c(5)]

```


```{r}

# Categorize the aspect ratios
imdb$aspect_ratio_category <- ifelse(imdb$aspect_ratio == 1.85, "1.85",
                                     ifelse(imdb$aspect_ratio == 2.35, "2.35", "Others"))

# Create dummy variables for 1.85 and 2.35 aspect ratios
imdb$aspect_ratio_1_85 <- ifelse(imdb$aspect_ratio_category == "1.85", 1, 0)
imdb$aspect_ratio_2_35 <- ifelse(imdb$aspect_ratio_category == "2.35", 1, 0)

# Now, if both dummy_1_85 and dummy_2_35 are 0, it means the movie belongs to the "Others" category.

```


```{r}
#Removing maturity_rating and aspect ratio column
imdb = imdb[,-c(5,6)]
```


```{r}

#Highly expereinced - more than 6 movies, experienced 2 to 6 movies, less experienced means 1

# Count the number of movies per cinematographer and merge this info back into the original dataframe
imdb <- imdb %>%
  left_join(imdb %>%
              group_by(cinematographer) %>%
              summarise(num_movies = n()), by = "cinematographer")

# Create a new categorical variable based on the number of movies
imdb$cinematographer_experience <- ifelse(imdb$num_movies > 6, 'Highly experienced',
                                          ifelse(imdb$num_movies > 1, 'Experienced', 'Less experienced'))

# Create dummy variables. We exclude the first level to use it as a reference category (which will be 'Highly experienced' if your factor levels are ordered alphabetically)
imdb <- imdb %>%
  mutate(cinematographer_experienced = as.integer(cinematographer_experience == 'Experienced'),
         cinematographer_less_experienced = as.integer(cinematographer_experience == 'Less experienced'))

# View the first few rows of the modified dataframe
head(imdb[, c("cinematographer", "num_movies", "cinematographer_experience", "cinematographer_experienced", "cinematographer_less_experienced")])

#Removing cinematographer_experience, distribution companies and director column 
imdb = imdb[,-c(5,7,68)]
```

```{r}
#removing cinematographer original column
imdb = imdb[,-c(11)]
```


```{r}

# Create dummy variables for release_month using model.matrix
# The '-1' ensures we don't get an intercept column
dummies <- model.matrix(~ release_month - 1, data = imdb)

# Convert the matrix to a dataframe
dummies_df <- as.data.frame(dummies)

# Drop the column corresponding to May
dummies_df$release_monthMay <- NULL

# Bind the dummies to the original dataframe
imdb <- cbind(imdb, dummies_df)

# Now, the imdb dataframe will have new columns for each month (except May). If all these columns are 0, it indicates May.


```


```{r}
#Removing release_month original column

imdb = imdb[,-c(3)]
```

```{r}
#removing unnecessary column
imdb = imdb[,-c(60)]
```


```{r}
library(purrr)


#Min-max scaling as a lot of dummies
# Select numeric columns to scale, excluding 'imdb_score'
numeric_columns <- imdb %>%
  select_if(~ is.numeric(.) && !identical(., imdb$imdb_score))

# Apply min-max scaling using purrr::map_df for consistency
scaled_data <- map_df(numeric_columns, ~ (. - min(., na.rm = TRUE)) / 
                      (max(., na.rm = TRUE) - min(., na.rm = TRUE)))

# Combine the scaled columns with the original dataframe
# Here, we replace the original columns with the scaled ones
imdb[names(scaled_data)] <- scaled_data

# View the first few rows of your scaled dataframe
head(imdb)

#This code will min-max scale all numeric columns in the imdb dataframe, excluding the imdb_score column, which is your target variable.

```

Judging Skewness

```{r}
a=names(imdb)

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    a1 = mean(imdb[[i]])
    a2 = median(imdb[[i]])
    if (a1-a2 > 0){
      b =  sprintf("%s is positively skewed", a[[i]])
      print(a1-a2)
    }
    else if (a1-a2 < 0){
      b =  sprintf("%s is negatively skewed", a[[i]])
      print(a1-a2)
    }
    else{
      b = sprintf("%s is not skewed", a[[i]])
    }
    cat(b, "\n")  # Print the assessment
  }
}
```

Lets map out the outliers
```{r}
library(ggplot2)
library(ggfortify)

for (i in 1:9) {
  if (is.numeric(imdb[[a[i]]])){
    # Create QQ plot using ggplot2 with ggfortify
    p <- ggplot(imdb, aes(sample = imdb[[a[i]]])) +
      stat_qq(color = "#ffa600") + 
      stat_qq_line(color = "#003f5c") +
      labs(title = paste("QQ Plot for", a[i]), x = "Theoretical Quantiles", y = "Sample Quantiles")
    print(p)
  }
}


```
```{r}
#Rows index for outliers in each column

#Initializing sums variable
sums = 0

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    all_outliers = list()
    
    #Converting into z-score to see which rows are outliers
    z_scores = scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers = abs(z_scores) > 3
    
    #Which rows are outliers
    all_outliers = which(outliers)
    
    print(all_outliers)
    cat("\n")
    
    #Variable to see number of outliers for each variable
    num = length(all_outliers)
    result = sprintf("Number of outliers: %d", num)
    print(result)
    cat("\n")
    
    #Variable to store total number of outliers
    sums = sums + num
    
  }
}
#Printing total number of outliers
sprintf("Total number of outliers: %d",sums)
```


```{r}
#PRinting the rows with outliers in more than 1 column

# Initialize the vectors
outlier_rows <- c()
all_outliers_list <- list()

for (i in 1:9) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    
    # Convert into z-score to see which rows are outliers
    z_scores <- scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers <- abs(z_scores) > 3
    
    # Append outlier row indices to the vector
    outlier_rows <- c(outlier_rows, which(outliers))
    
    # Store outliers for each column in a list for reference
    all_outliers_list[[a[i]]] <- which(outliers)
  }
}

# Count the frequency of each row index in the outlier_rows vector
row_counts <- table(outlier_rows)

# Identify rows with frequency greater than 1
multi_outlier_rows <- as.integer(names(row_counts[row_counts > 1]))

# Print the rows with outliers in more than one column
sprintf("The rows with more than 1 oultier is %d",multi_outlier_rows)

```


```{r}
#Removing the rows with columns having more than 1 outliers and also removing keywords_other

imdb = imdb[-c(40,87,128,823,1331,1360,1498,1692),]
imdb = imdb[,-c(31)]
```

Correlation

```{r}
library(corrplot)

# Exclude the movie_id column and select only the numeric columns for correlation
numeric_data <- imdb[sapply(imdb, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% "movie_id"]

# Exclude columns with only one unique value or with NA values
numeric_data <- numeric_data[, sapply(numeric_data, function(x) length(unique(x[!is.na(x)])) > 1)]

# Compute the correlation matrix
cor_matrix <- cor(numeric_data, use = "pairwise.complete.obs", method = "pearson")

# Visualize the correlation matrix with smaller labels
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45, tl.cex = 0.5)  # Adjust the tl.cex value as needed

```
```{r}
# Pairplot
install.packages("GGally")
library(GGally)

selected_columns <- c("imdb_score", "movie_budget", "duration", "nb_news_articles", 

                      "actor1_star_meter", "actor2_star_meter", "actor3_star_meter", 

                      "nb_faces", "movie_meter_IMDBpro")

imdb_selected <- imdb[, selected_columns]

ggpairs(imdb_selected) +  ggtitle("PairPlot")

```


```{r}
library(igraph)
library(ggraph)

# Create a graph from the correlation matrix
cor_graph <- graph_from_adjacency_matrix(cor_matrix > 0.5, weighted = TRUE, mode = "undirected")

# Plot the graph
ggraph(cor_graph, layout = "fr") +
  geom_edge_link(aes(width = weight), alpha = 0.2) +
  geom_node_point(color = "blue", size = 2) +
  geom_node_text(aes(label = name), repel = TRUE) +
  theme_void()

```


```{r}
#Checking if there is/are any combination(s) with value > 0.50 for coorelation
library(reshape2)

cor_matrix = cor(imdb, method = "pearson")

# Convert correlation matrix to long format
long_format <- melt(cor_matrix)
head(long_format)

# Filter correlations greater than 0.80 (in absolute terms) and exclude self-correlations
high_correlations <- long_format %>%
  filter(abs(value) > 0.50 & Var1 != Var2)

# Print the pairs with high correlations
print(high_correlations)

```


```{r}
#Removing num_movies column
imdb = imdb[,-c(59)]

library(dplyr)
 
imdb <- imdb %>%
  rename(maturity_ratingPG_13 = `maturity_ratingPG-13`)
```


```{r}
#Checking for non-linearity 
require(car)


reg = lm(imdb_score~.,data = imdb)
summary(reg)

# residualPlots(reg)
# Uncomment to see residual plots, press return to proceed

```


```{r}
#Checking heteroskedasticity
ncvTest(reg)

#There is a high probability of heteroskedasticity
```
```{r}
#Correcting heteroskedasticity
require(lmtest)
require(plm)

coeftest(reg, vcov=vcovHC(reg, type='HC1'))
```


```{r}
#These are some suggestions (after non-linear) , did not removed
reg2 = lm(imdb_score~.+movie_budget*actor1_star_meter,data = imdb)
summary(reg2)
vif(reg2)
```


```{r}
#removing all keywords column
imdb = imdb[,-c(31:50)]
```


```{r}
# Create an empty vector to store all outlier indices
all_outliers <- c()

for (i in 1:7) {
  # Checks if the column is numeric
  if (is.numeric(imdb[[a[i]]])){
    # Converting into z-score to see which rows are outliers
    z_scores = scale(imdb[[a[i]]])
    
    # Identify outliers based on a threshold (e.g., |Z-score| > 3)
    outliers = abs(z_scores) > 3
    
    # Which rows are outliers
    column_outliers = which(outliers)
    
    print(column_outliers)
    cat("\n")
    
    # Append the outlier indices to the all_outliers vector
    all_outliers = c(all_outliers, column_outliers)
    
    # Variable to see the number of outliers for each variable
    num = length(column_outliers)
    result = sprintf("Number of outliers for column %s: %d", a[i], num)
    print(result)
    cat("\n")
  }
}

# Get unique outlier indices (since a row can be an outlier in multiple columns)
unique_outliers <- unique(all_outliers)

# Remove rows with outliers
imdb <- imdb[-unique_outliers, ]

# Print the total number of unique outlier rows
sprintf("Total number of unique outlier rows: %d", length(unique_outliers))

```


```{r}
# Final Model 

reg3 = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-release_monthOct-release_monthMar-release_monthJan-num_movies-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)
summary(reg3)
```

```{r}
#Using train-test split
library(caTools)
sample=sample.split(imdb$imdb_score, SplitRatio=0.8)
train_set=subset(imdb, sample==TRUE)
test_set=subset(imdb, sample==FALSE)
fit = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-release_monthOct-release_monthMar-release_monthJan-num_movies-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = train_set)

actual=test_set$imdb_score
prediction=predict(fit, test_set)
squared_error=(actual-prediction)^2
mse=mean(squared_error)
mse
```


```{r}
#Using LOOCV 

library(boot)
fit1= glm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-release_monthOct-release_monthMar-release_monthJan-num_movies-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)

mse=cv.glm(imdb, fit1)$delta[1]
mse
```


```{r}
# Diagnostic Plots
par(mfrow = c(2, 2))  # Optional: Arrange plots in a 2x2 grid
plot(reg3)

```


```{r}
library(ggplot2)
library(broom)

# Tidy the model output to get a data frame
tidy_reg3 <- tidy(reg3)



# Create a coefficient plot using ggplot2
ggplot(tidy_reg3, aes(x = estimate, y = term, color = p.value < 0.05)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - std.error, xmax = estimate + std.error), height = 0) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  scale_color_manual(values = c("TRUE" = "blue", "FALSE" = "grey")) +
  labs(y = "Predictors", x = "Estimate", color = "Significant") +
  theme_minimal()

```

```{r}
######## TEST DATASET & PREDICTION
```
 
 ---
title: "Midterm"
output: html_document
date: "2023-10-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(knitr)
library(stringr)
library(dplyr)

# %>% - we use this to store function output and pass it to 

tests = read.csv("test_data_imdb_Fall_2023.csv")
attach(tests)
#Removing genres dummy as they are not covering all the genres
tests = tests[,-(27:39)]

# Step 1: Identify all unique genres
all_genres = tests %>%
  pull(genres) %>%
  str_split("\\|") %>%
  unlist() %>%
  unique()

# Step 2: For each genre, create a new column
for (genre in all_genres) {
  column_name <- str_c("genre_", genre) %>% str_replace_all(" ", "_")  # Create a valid column name
  tests <- tests %>%
    mutate(!!column_name := as.integer(str_detect(genres, fixed(genre))))
}
```


```{r}
#Removing original genres
tests = tests[,-(24)]
```

Dummifying keywords based on top 20 keywords (with each dummy for one of the top 20 keyword
and rest belong to others)


```{r}
library(dplyr)
library(tidyr)

# 1. Extract Keywords
keywords <- tests %>%
  select(plot_keywords) %>%
  mutate(plot_keywords = strsplit(as.character(plot_keywords), '\\|')) %>%
  unnest(plot_keywords) %>%
  mutate(plot_keywords = trimws(plot_keywords))

# 2. Count Keywords
keyword_counts <- keywords %>%
  group_by(plot_keywords) %>%
  summarise(n = n()) %>%
  arrange(desc(n))

# 3. Select Top Keywords
top_keywords <- head(keyword_counts, 20) %>% pull(plot_keywords)

# 4. Adjust the keywords, keeping only the top ones or marking as 'Other'
tests <- tests %>%
  mutate(
    adjusted_keywords = lapply(
      strsplit(as.character(plot_keywords), '\\|'),
      function(keyword_list) {
        adjusted_list <- sapply(keyword_list, function(keyword) {
          if (keyword %in% top_keywords) {
            return(keyword)
          } else {
            return('Other')
          }
        })
        # Deduplicate the list (remove repeating 'Other')
        return(unique(adjusted_list))
      }
    )
  ) %>%
  mutate(row_id = row_number())  # Add row identifier

# 5. Create Dummy Variables
tests_dummies <- tests %>%
  select(row_id, adjusted_keywords) %>%
  unnest(adjusted_keywords) %>%
  mutate(dummy = 1) %>%
  pivot_wider(id_cols = row_id, names_from = adjusted_keywords, values_from = dummy, values_fill = list(dummy = 0), names_prefix = "keyword_")

# Join the dummy variables with the original data
tests <- left_join(tests, tests_dummies, by = "row_id") %>%
  select(-row_id, -adjusted_keywords)  # Remove the row identifier and adjusted_keywords column


```


```{r}
#There are almost 80-90% of values in R, PG and PG13,so we can classify other categories into a new category called others

# Function to categorize maturity ratings
categorize_maturity_rating <- function(rating) {
  if (rating %in% c('PG-13', 'PG', 'R')) {
    return(rating)
  } else {
    return('Others')
  }
}

# Apply the function to the 'maturity_rating' column
tests$maturity_rating <- sapply(tests$maturity_rating, categorize_maturity_rating)

# Dummify the 'maturity_rating' column
dummy_vars <- model.matrix(~ maturity_rating - 1, data = tests) %>%
              as.data.frame()

# Keep only 'PG-13', 'PG', and 'R' columns, if they exist
dummy_vars <- dummy_vars[, colnames(dummy_vars) %in% c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')]

# If the columns don't exist in the dummy_vars (because they might not be present in the original data), 
# we need to create them and set them to zero.
necessary_columns <- c('maturity_ratingPG-13', 'maturity_ratingPG', 'maturity_ratingR')
for (col in necessary_columns) {
  if (!col %in% colnames(dummy_vars)) {
    dummy_vars[[col]] <- 0
  }
}

# Bind the dummy variables with the original dataframe
tests <- cbind(tests, dummy_vars)

# This will print the first few rows of your dataframe
head(tests)
```

Removing variables from the dataset which seem irrelevant

```{r}
tests = tests[,-c(1,2,3,6,8,17,19,21,23)]
```


```{r}

#Classified the production companies that produced more than 18 movies into famous category and the ones with lesser than 18 movies as non-famous. Created dummy with 1 = famous and 0 = non-famous

library(dplyr)

# Ensure that production_company is a character vector, not a factor
tests$production_company <- as.character(tests$production_company)

# Count occurrences of each production company
production_counts <- as.data.frame(table(tests$production_company))

# Name the columns for clarity
names(production_counts) <- c("production_company", "count")

# Categorize as 'famous' or 'non-famous'
production_counts$production_by <- ifelse(production_counts$count >= 18, 'famous', 'non-famous')

# Merge this information back into the original dataframe
tests <- merge(tests, production_counts[, c("production_company", "production_by")], by = "production_company")

# Create a dummy variable for 'famous'
tests$famous_production_company <- ifelse(tests$production_by == 'famous', 1, 0)


```


```{r}
#Removing original production_company and plot_keywords column
tests = tests[,-c(1,17)]
```


```{r}

#We observed that there 1115 unique directors, with a large portion of directors directing 1 or 2 movies. Therefore, we decided to split the directors columns into 3 categories where extremely prolific is the director directing more than 2 movies. Very prolific is the director directing 2 movies and low prolific is the director director direction 1 or 0 movies.

library(dplyr)

# First, ensure that 'director' is a factor
tests$director <- as.factor(tests$director)

# Calculate the number of movies for each director
director_counts <- table(tests$director)

# Function to categorize directors based on director counts
categorize_director <- function(director_name) {
  count <- director_counts[director_name]
  if (count > quantiles[2]) {
    return("Extremely Prolific")
  } else if (count > quantiles[1]) {
    return("Medium Prolific")
  } else {
    return("Less Prolific")
  }
}

# Calculate the quantiles based on the number of movies directed
quantiles <- quantile(director_counts, probs = c(0.3, 0.7))

# Categorize directors
tests$director_category <- sapply(tests$director, categorize_director)

# Create dummy variables
tests <- tests %>%
  mutate(
    director_extremely_prolific = ifelse(director_category == "Extremely Prolific", 1, 0),
    director_very_prolific = ifelse(director_category == "Medium Prolific", 1, 0)
  )

# View the first few rows of the modified dataframe
head(tests)


```


```{r}
library(dplyr)

# Ensure that 'distributor' is a factor
tests$distributor <- as.factor(tests$distributor)

# Define the threshold
threshold <- 40

# Calculate the number of movies for each distributor
distributor_counts <- table(tests$distributor)

# Function to categorize distributors
categorize_distributor <- function(distributor_name) {
  count <- distributor_counts[distributor_name]
  if (count > threshold) {
    return("Major Distributors")
  } else {
    return("Independent Distributors")
  }
}

# Categorize distributors
tests$distributor_category <- sapply(tests$distributor, categorize_distributor)

# Create a dummy variable for major distributors
tests$major_distributor <- ifelse(tests$distributor_category == "Major Distributors", 1, 0)

# View the first few rows of the modified dataframe
head(tests)

```

```{r}
#Removing director category, production company and distribution company variables which contained the new custom categories we created. We have already created dummies using those custom categories.

tests = tests[,-c(56,58,61)]
```



```{r}
#Removing languages as it is an almost unary predictor

tests = tests[,-c(5)]

```


```{r}
# Transform the 'country' column
tests <- tests %>%
  mutate(country = ifelse(country == 'USA', 'USA', 'Non-USA'))

# Create a dummy variable
tests$country_usa <- ifelse(tests$country == 'USA', 1, 0)

# View the first few rows of the modified dataframe
head(tests[, c("country", "country_usa")])
```

```{r}
#Removing original country variable
tests = tests[,-c(5)]

```


```{r}

# Categorize the aspect ratios
tests$aspect_ratio_category <- ifelse(tests$aspect_ratio == 1.85, "1.85",
                                     ifelse(tests$aspect_ratio == 2.35, "2.35", "Others"))

# Create dummy variables for 1.85 and 2.35 aspect ratios
tests$aspect_ratio_1_85 <- ifelse(tests$aspect_ratio_category == "1.85", 1, 0)
tests$aspect_ratio_2_35 <- ifelse(tests$aspect_ratio_category == "2.35", 1, 0)

# Now, if both dummy_1_85 and dummy_2_35 are 0, it means the movie belongs to the "Others" category.

```


```{r}
#Removing maturity_rating and aspect ratio column
tests = tests[,-c(5,6)]
```


```{r}

#Highly experienced - more than 6 movies, experienced 2 to 6 movies, less experienced means 1

# Count the number of movies per cinematographer and merge this info back into the original dataframe
tests <- tests %>%
  left_join(tests %>%
              group_by(cinematographer) %>%
              summarise(num_movies = n()), by = "cinematographer")

# Create a new categorical variable based on the number of movies
tests$cinematographer_experience <- ifelse(tests$num_movies > 6, 'Highly experienced',
                                          ifelse(tests$num_movies > 1, 'Experienced', 'Less experienced'))

# Create dummy variables. We exclude the first level to use it as a reference category (which will be 'Highly experienced' if your factor levels are ordered alphabetically)
tests <- tests %>%
  mutate(cinematographer_experienced = as.integer(cinematographer_experience == 'Experienced'),
         cinematographer_less_experienced = as.integer(cinematographer_experience == 'Less experienced'))

# View the first few rows of the modified dataframe
head(tests[, c("cinematographer", "num_movies", "cinematographer_experience", "cinematographer_experienced", "cinematographer_less_experienced")])
```


```{r}
#Removing cinematographer_experience, distribution companies and director column 
tests = tests[,-c(5,7)]
```


```{r}
#removing cinematographer original column
tests = tests[,-c(11)]
```


```{r}

# Trim whitespace from the release_month column
tests$release_month <- trimws(tests$release_month)

# Create a binary dummy variable for November
tests$November <- as.numeric(tests$release_month == "Nov")


```


```{r}
#Removing release_month original column

tests = tests[,-c(3)]
```


```{r}
#Unnecessary column
tests = tests[,-c(53)]
```


```{r}
#Making movie budget a numerical column
tests$movie_budget = as.integer(gsub(",","",tests$movie_budget))
```


```{r}
#unnecessary column
tests = tests[,-c(56)]
```


```{r}
library(purrr)

# Select numeric columns to scale, excluding 'tests_score' and the 48th, 49th, and 50th columns
numeric_columns <- tests %>%
  select_if(~ is.numeric(.) && !identical(., tests$imdb_score)) %>%
  select(-c(47, 48, 49,50,51,55,56,57))

# Apply min-max scaling using purrr::map_df for consistency
scaled_data <- map_df(numeric_columns, ~ (. - min(., na.rm = TRUE)) / 
                      (max(., na.rm = TRUE) - min(., na.rm = TRUE)))

# Combine the scaled columns with the original dataframe
# Here, we replace the original columns with the scaled ones
tests[names(scaled_data)] <- scaled_data

# View the first few rows of your scaled dataframe
head(tests)


#This code will min-max scale all numeric columns in the tests dataframe, excluding the tests_score column, which is your target variable.

```


```{r}
#Removing num_movies column
tests = tests[,-c(55)]
```


```{r}
#removing all keywords column
tests = tests[,-c(24:44)]
```


```{r}

# Store the column names of training data
train_cols <- colnames(imdb)

# Add missing columns to test_data with 0s
for (col in train_cols) {
  if (!col %in% colnames(tests)) {
    tests[[col]] <- 0
  }
}

# Remove extra columns from test_data
tests <- tests[, train_cols]

```


```{r}
#This is the final model

reg3 = lm(imdb_score~.+genre_Drama*genre_Thriller-duration-genre_Romance-maturity_ratingPG-movie_meter_IMDBpro-movie_budget-nb_news_articles-release_monthFeb-actor1_star_meter-release_monthJun-release_monthNov-release_monthAug-genre_History-release_monthDec-actor3_star_meter-cinematographer_experienced-cinematographer_less_experienced-director_very_prolific-genre_Sci_Fi-release_monthJul-genre_Mystery-genre_Biography-aspect_ratio_2_35-actor2_star_meter-major_distributor-genre_Fantasy-release_monthApr-genre_War-genre_Musical-release_monthOct-release_monthMar-release_monthJan-num_movies-maturity_ratingR+log(nb_news_articles+0.0001)+log(movie_budget+0.0001)+log(movie_meter_IMDBpro+0.0001)-release_monthFeb-famous_production_company-genre_Music-genre_Adventure-release_monthSep+poly(duration,2)-genre_Western-genre_Thriller,data = imdb)

summary(reg3)

predicted_scores = predict(reg3, newdata = tests)
tests$predicted_imdb_score = predicted_scores
predicted_scores
```

```{r}
# stargazer
library(stargazer)
stargazer(reg3, type = "html")
```

```{r}
```

